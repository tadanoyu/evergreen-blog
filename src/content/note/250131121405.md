---
title: "루비는 사용되지 않는 메모리를 알아서 회수한다"
folge: "1b2a"
uid: "250131121405"
pubDate: "January 31 2025 12:25"
updatedDate: "April 26 2025 20:55"
---

C/C++와 같이 직접 메모리 관리를 해야하는 언어의 경우, [메모리의 할당 및 해제를 명시적으로 해주어야 한다](/note/250130081822). 하지만 Ruby와 같이 가비지 컬렉터가 있는 언어의 경우, 메모리 관리를 알아서 해주기 때문에 메모리를 직접 할당하거나 해제할 필요가 없다.

아래 `name`과 `age`를 인자로 받는 `Person` 클래스가 있다.

```rb
class Person
	def initialize(name, age)
		@name = name
		@age = age
	end

	def to_s
		"Name: #{@name}  Age: #{@age}"
	end
end

10.times do |i|
	person = Person.new("person#{i}", 17 + i.to_i)
	puts person.to_s
end
```

`Person.new`를 사용해서 `Person` 오브젝트를 10번 반복해서 생성해주고 있지만 따로 해제를 하고 있지는 않다. C++이었다면 `person` 이라는 변수에 메모리를 할당했고, 해제하지 않은 채 새로운 메모리를 다시 할당 한 시점에 이미 메모리 누수가 발생한다. 왜냐면 메모리 해제를 하고 싶어도, 해당 메모리를 가리키고 있는 변수가 더 이상 없기 때문. 

하지만 루비의 경우 가비지 컬렉터가 해당 작업을 알아서 해준다. 반복문을 보면 각 반복에서 `person` 변수에 새 객체가 할당되고, 이전 객체는 도달할 수 없는 상태가 된다. 해당 객체에 접근할 수 없고 참조하고 있는 변수조차 없다면, 루비의 가비지 컬렉터는 해당 객체를 삭제하고 할당된 메모리를 해제한다.