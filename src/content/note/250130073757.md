---
title: "정적 배열과 동적 배열의 차이"
folge: "1b1"
uid: "250130073757"
pubDate: "January 30 2025 20:07"
updatedDate: "April 26 2025 15:20"
---

> "배열의 크기에 대한 정보를 가지고 있는가 없는가"

## 정적 배열

만약 크기에 대한 정보를 사전에 알고 있다면, 컴파일 시점에 정적으로 배열을 생성하면 된다. 정적 배열이기 때문에 크기를 줄이거나 늘릴 수 없지만, 어느정도의 메모리가 필요한지 미리 알고 있었기 때문에 크게 걱정 할 필요는 없다. 

한 가지 단점이라면, 어느 시점에서든 항상 고정된 크기를 가진다는 점. 예를들어 크기 100을 가진 정적 배열을 만들면, 해당 배열의 원소가 한 개가 있든 열 개가 있든, 항상 100개 만큼의 원소를 담을 수 있는 크기의 메모리를 할당하고 있어야 하므로 메모리 낭비가 될 수도 있다.

## 동적 배열

크기에 대한 정보를 알 수 없거나, 프로그램 실행 도중 크기가 정해지는 경우는 동적 배열을 사용할 수 밖에 없다. 

동적으로 메모리를 할당하기 때문에 프로그램 실행 중 어느 시점에서도 배열의 크기를 줄이거나 늘릴 수 있다는 장점이 있다. 정적 배열의 단점이었던 메모리 활용도가 동적 배열에서는 크게 올라간다.

단점도 당연히 있다. 첫 번째로는 메모리 누수의 가능성이 있다 (가비지 컬렉터가 있다면 메모리 걱정은 크게 하지 않아도 된다).

동적으로 메모리를 할당한다는 얘기는, 해당 메모리를 우리가 관리해야 한다는 뜻이다. 즉, 사용하지 않는 메모리를 추적해서 메모리 해제(deallocate)를 해줘야 한다. 메모리 해제를 하지 않고 계속 새로운 메모리를 할당해버리면 메모리 공간이 부족해지고 성능 문제를 야기하게 된다. 

두 번째는 단점 아닌 단점인데, 바로 코드가 상대적으로 복잡해진다는 것. 아래는 C언어의 1차원 배열 예제이지만, 다차원의 경우 코드는 좀 더 복잡해진다. 하지만 이는 사용하는 언어의 문법에 따라 다르기 때문에, 단점이라고 딱 꼬집어서 말하기는 힘들다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(int argc, char **argv) {
	// 정적 배열
	int sarr[3] = {1, 2, 3};
	printf("sarr[0]: %d\n", sarr[0]);


	// 동적 배열
	int *darr;
	darr = (int *)malloc(sizeof(int) * 3);
	darr[0] = 1;
	printf("darr[0]: %d\n", darr[0]);
	free(darr);
	
	return 0;
}
```

위는 C언어의 경우로, C++에서는 동적 배열의 선언이 훨씬 간단하기는 하다.
