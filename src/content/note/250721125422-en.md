---
title: "<$> Singly Linked List"
folge: "0a"
uid: "250721125422"
lang: "en"
pubDate: "June 21 2025 12:54"
---

Singly [Linked List](/en/note/250707122604-en/) implementation with Ruby.

```rb
Node = Struct.new(:data, :next) do
    def new
        @data = self.data
        @next = self.next
    end
end

class SinglyLinkedList
    def initialize()
        @head = nil
        @size = 0
    end

    def push_front(data)
        if @head == nil
            @head = Node.new(data, nil)
        else
            @head = Node.new(data, @head)
        end

        @size += 1
    end

    def push_back(data)
        new_node = Node.new(data, nil)

        if @head == nil
            @head = new_node
        else
            temp = @head
            while temp.next
                temp = temp.next
            end

            temp.next = new_node
        end

        @size += 1
    end

    def pop_front
        raise "err: list is empty" if @head == nil
        
        @size -= 1
        @head = @head.next
    end

    def pop_back
        raise "err: list is empty" if @head == nil

        curr = @head
        if curr.next == nil
            @head = nil
        else
            while curr.next && curr.next.next != nil
                curr = curr.next
            end

            curr.next = nil
        end

        @size -= 1
    end

    def del_at(pos)
        raise "err: invalid 'pos' was given" if pos < 0 || pos >= @size

        if pos == 0
            pop_front
        elsif pos == @size-1
            pop_back
        else
            curr = @head
            (pos-1).times { curr = curr.next }
            curr.next = curr.next.next
            @size -= 1
        end

    end

    def del(data)
        pos = find(data)
        return -1 if pos == -1

        del_at(pos)
    end

    def find(data)
        return -1 if @head == nil

        curr = @head
        pos = 0
        while curr 
            return pos if curr.data == data
            curr = curr.next
            pos += 1
        end

        -1
    end

    def size
        return @size    
    end

    def reverse
        c = @head
        n = @head
        p = nil

        while n
            n = c.next 
            c.next = p
            p = c
            c = n
        end

        @head = p
    end

    def print(delim=' ')
        return if @head == nil

        temp = @head

        while temp.next != nil
            printf("%d%c ", temp.data, delim)
            temp = temp.next
        end

        printf("%d\n", temp.data)
    end

    def clear
        @head = nil
        @size = 0
    end
end
```