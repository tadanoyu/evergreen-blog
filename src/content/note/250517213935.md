---
title: "연결리스트의 머리 관리를 못하면 메모리 누수가 발생한다"
folge: "0d0"
uid: "250517213935"
pubDate: "May 17 2025 21:22"
---

연결리스트의 경우 노드들이 포인터로 이루어져 있는 구조이기 때문에 다른 노드들에 접근하기 위해서는 시작점(`head`) 에서부터 순차적으로 순회를 해야한다.

다르게 말하면 시작점이 없어지는 순간, 그 이후에 연결되어 있는 모든 노드들에 접근할 수 있는 방법이 사라지는 것과 같다. 

노드는 동적으로 할당이 되기 때문에 연결리스트가 소멸될 때, 노드들을 순차적으로 돌면서 할당한 메모리를 해제해야 한다. 하지만 실수로 `head`를 지워버리거나 다른 값으로 덮어씌어버리면, 기존에 할당되었던 노드들의 메모리를 해제할 수 없게 되고 이는 결국 메모리 누수(memory leak)로 이어진다.

## 확장 🌱
- [ ] 실수를 방지하기 위한 해결책이 있을까?
  - doubly linked list에는 `tail`이 있으니까 `head`가 없어져도 복구 가능 
  - circular linked list는 `tail`이 `head`를  가리키니까, 마찬가지로 복구 가능
  - 노드를 `const`로 만들어서 함부로 값을 덮어씌우지 못하게 할수 있을 것 같고..
- [x] 위와 같은 이유로 대상에 접근할 수 없어서 메모리 해제를 못하는 경우를 Dangling Pointer라고 했었나? 
  + Dangling pointer는 유효하지 않은 메모리 주소를 가지는 포인터를 의미
- [ ] 메모리 누수가 프로그램에 끼치는 영향은?
- [ ] 메모리 관리를 직접하지 않는 언어의 경우 (e.g. Ruby, python, JavaScript, Java, etc..) 메모리 누수로부터 안전할까?
- [ ] `head`가 다른 변수에 복사되어 있다면 메모리 누수는 발생하지 않나?
- [ ] Garbage collector가 있는 언어의 경우 해당 이슈가 발생하지 않을까?

## 관련 노트 📘
- [250513192645](/note/250513192645) - 연결리스트의 조회는 순차적으로 이루어진다
